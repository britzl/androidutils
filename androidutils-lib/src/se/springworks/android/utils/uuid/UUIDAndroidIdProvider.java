package se.springworks.android.utils.uuid;

import java.io.UnsupportedEncodingException;
import java.util.UUID;

import android.content.Context;
import android.content.SharedPreferences;
import android.provider.Settings.Secure;
import android.telephony.TelephonyManager;

import com.google.inject.Inject;

/**
 * Returns a unique UUID for the current android device. As with all UUIDs, this
 * unique ID is "very highly likely" to be unique across all Android devices.
 * Much more so than ANDROID_ID is.
 * 
 * The UUID is generated by using ANDROID_ID as the base key if appropriate,
 * falling back on TelephonyManager.getDeviceID() if ANDROID_ID is known to be
 * incorrect, and finally falling back on a random UUID that's persisted to
 * SharedPreferences if getDeviceID() does not return a usable value.
 * 
 * In some rare circumstances, this ID may change. In particular, if the device
 * is factory reset a new device ID may be generated. In addition, if a user
 * upgrades their phone from certain buggy implementations of Android 2.2 to a
 * newer, non-buggy version of Android, the device ID may change. Or, if a user
 * uninstalls your app on a device that has neither a proper Android ID nor a
 * Device ID, this ID may change on reinstallation.
 * 
 * Note that if the code falls back on using TelephonyManager.getDeviceId(), the
 * resulting ID will NOT change after a factory reset. Something to be aware of.
 * 
 * Works around a bug in Android 2.2 for many devices when using ANDROID_ID
 * directly.
 * 
 * Note: Requires <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
 * 
 * @see http://code.google.com/p/android/issues/detail?id=10603
 * 
 */
// From http://stackoverflow.com/a/5626208/1266551
public class UUIDAndroidIdProvider implements UUIDProvider {

	public static final String BROKEN_ANDROID_ID = "9774d56d682e549c";
	
	private Context context;
	
	protected static final String PREFS_FILE = "device_id.xml";
	protected static final String PREFS_DEVICE_ID = "device_id";
	protected volatile static UUID uuid;

	@Inject
	public UUIDAndroidIdProvider(Context context) {
		this.context = context;
		if (uuid == null) {
			synchronized (UUIDAndroidIdProvider.class) {
				if (uuid == null) {
					final SharedPreferences prefs = context.getSharedPreferences(PREFS_FILE, 0);
					final String id = prefs.getString(PREFS_DEVICE_ID, null);
					if (id != null) {
						// Use the ids previously computed and stored in the
						// prefs file
						uuid = UUID.fromString(id);
					}
					else {
						final String androidId = Secure.getString(context.getContentResolver(), Secure.ANDROID_ID);
						uuid = getUUIDForAndroidId(androidId);
						prefs.edit().putString(PREFS_DEVICE_ID, uuid.toString()).commit();
					}
				}
			}
		}
	}

	@Override
	public UUID get() {
		return uuid;
	}
	
	
	/**
	 * Get a UUID based on {@link Secure.ANDROID_ID}
	 * Use the Android ID unless it's broken, in which case fallback on deviceId,
	 * unless it's not available, then fallback on a random number
	 * @param androidId
	 * @return
	 */
	public UUID getUUIDForAndroidId(String androidId) {
		try {
			if (!BROKEN_ANDROID_ID.equals(androidId)) {
				return UUID.nameUUIDFromBytes(androidId.getBytes("utf8"));
			}
			else {
				final String deviceId = ((TelephonyManager) context
						.getSystemService(Context.TELEPHONY_SERVICE))
						.getDeviceId();
				return (deviceId != null && !"000000000000000".equals(deviceId)) ? UUID.nameUUIDFromBytes(deviceId.getBytes("utf8")) : UUID.randomUUID();
			}
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
	}

}
